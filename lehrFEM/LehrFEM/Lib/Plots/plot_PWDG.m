function varargout = plot_PWDG(U,Mesh,omega,nrefs,doplots)
%PLOT_PWDG plot plane wave discontinuous Galerkin solution
%   
%   PLOT_PWDG(U,MESH,OMEGA,NREFS) generates plots of the real and imaginary
%   parts of the element in the space spanned by discontinuous plane waves
%   on the mesh MESH represented by U.  The plots are piecewise linear on
%   a mesh generated by NREFS regular refinements of the mesh MESH.
%
%   OMEGA is the (scalar) wave number of the plane wave basis functions.
%
%   The struct MESH must contain at least the following fields:
%    COORDINATES M-by-2 matrix specifying the vertices of the mesh.
%    ELEMENTS    N-by-3 or N-by-4 matrix specifying the elements of the
%                mesh.
%    ELEMDATA    N-by-1 structure array containing at least the fields:
%       NDOFS       The number of degrees of freedom on the corresponding
%                   element.
%       DIR         P-by-2 matrix specifying the propagation directions of
%                   the plane wave basis functions.
%
%   PLOT_PWDG(U,MESH,OMEGA,NREFS,DOPLOTS) where DOPLOTS is a logical vector
%   of length three generates each of the following plots if the
%   corresponding entry of DOPLOTS is true (or 1):
%     1) real part
%     2) imaginary part
%     3) absolute value
%
%   Example :
%
%     plot_PWDG(U,Mesh,pi,3)
%
%   See also plot_PWDG_Dir, contour_PWDG, set_Data_PWDG.

%   Copyright 2007-2007 Claude Gittelson
%   SAM - Seminar for Applied Mathematics
%   ETH-Zentrum
%   CH-8092 Zurich, Switzerland

  % Set default arguments
  if(nargin<5 || isempty(doplots))
    doplots = [true true false];
  elseif(isa(doplots,'numeric'))
    doplots = logical(doplots);
  end

  % Initialize constants
  OFFSET = 0.05;
  nElements = size(Mesh.Elements,1); % Number of elements
  nVert = size(Mesh.Elements,2);  % Number of vertices per element
  nDofs = [Mesh.ElemData.nDofs];  % Number of degrees of freedom on each element
  nDofsSum = cumsum([0,nDofs]);   % Number of degrees of freedom on all preceading elements
  
  % Compute axes limits
  XMin = min(Mesh.Coordinates(:,1));
  XMax = max(Mesh.Coordinates(:,1));
  YMin = min(Mesh.Coordinates(:,2));
  YMax = max(Mesh.Coordinates(:,2));
  XLim = [XMin XMax] + OFFSET*(XMax-XMin)*[-1 1]; 
  YLim = [YMin YMax] + OFFSET*(YMax-YMin)*[-1 1];
  
  % Calculate dimensions of local mesh (number of vertices,edges,elements)
  if(nVert==3) % triangular elements
    dims = [3 3 1]';
    T = [1 1 0
         0 2 3
         0 0 4];
  elseif(nVert==4) % quadrilateral elements
    dims = [4 4 1]';
    T = [1 1 1
         0 2 4
         0 0 4];
  end
  dims = T^nrefs*dims;
  nLocVert = dims(1);
  nLocElem = dims(3);
  
  % Generate auxiliary mesh and evaluate plane wave function
  Coordinates = zeros(nLocVert*nElements,2);
  Elements = zeros(nLocElem*nElements,nVert);
  Values = zeros(nLocVert*nElements,1);
  
  for j=1:nElements
    % Construct local mesh
    vidx = Mesh.Elements(j,:); 
    LocMesh.Coordinates = Mesh.Coordinates(vidx,:);
    LocMesh.Elements = 1:nVert;
    LocMesh = add_Edges(LocMesh);         
    LocBd = get_BdEdges(LocMesh);
    LocMesh.BdFlags = zeros(size(LocMesh.Edges,1),1); 
    LocMesh.BdFlags(LocBd) = -1;
    DistArgs = {};
    if(isfield(Mesh.ElemData,'Geom') && Mesh.ElemData(j).Geom.isParam)
      DistArgs = {Mesh.ElemData(j).Geom.Dist};
    end
    for k=1:nrefs
      LocMesh = refine_REG(LocMesh,DistArgs{:});
    end
    LocMesh = rmfield(LocMesh,'BdFlags');
    
    % Define patch coordinates and elements
    Elements((j-1)*nLocElem+1:j*nLocElem,:) = (j-1)*nLocVert+LocMesh.Elements;
    Coordinates((j-1)*nLocVert+1:j*nLocVert,:) = LocMesh.Coordinates;
    
    % Evaluate function at grid points
    x0 = Mesh.Coordinates(Mesh.Elements(j,1),:);
    Dir = Mesh.ElemData(j).Dir;
    ind = nDofsSum(j)+(1:nDofs(j));
    Values((j-1)*nLocVert+1:j*nLocVert) = ...
      exp(i*omega*(LocMesh.Coordinates-x0(ones(nLocVert,1),:))*Dir.')*U(ind);
  end
  
  % Compute color axes limits 
  CMin = min([real(Values); imag(Values)]);
  CMax = max([real(Values); imag(Values)]);
  CLim = [CMin CMax] + OFFSET*(CMax-CMin)*[-1 1];
  CMinAbs = min(abs(Values));
  CMaxAbs = max(abs(Values));
  CLimAbs = [CMinAbs CMaxAbs] + OFFSET*(CMinAbs-CMaxAbs)*[-1 1];
  
  % Plot finite element solution
  fig = zeros(1,3);
  
  if(doplots(1)) % real part
    fig(1) = figure('Name','Plane wave DG finite elements');
    patch('faces', Elements, ...
          'vertices', [Coordinates, real(Values)], ...
          'CData', real(Values), ...
          'facecolor', 'interp', ...
          'edgecolor', 'none');
    set(gca,'XLim',XLim,'YLim',YLim,'CLim',CLim,'DataAspectRatio',[1 1 1]);
    title('\bf Real Part');
  end
  
  if(doplots(2)) % imaginary part
    fig(2) = figure('Name','Plane wave DG finite elements');
    patch('faces', Elements, ...
          'vertices', [Coordinates, imag(Values)], ...
          'CData', imag(Values), ...
          'facecolor', 'interp', ...
          'edgecolor', 'none');  
    set(gca,'XLim',XLim,'YLim',YLim,'CLim',CLim,'DataAspectRatio',[1 1 1]);
    title('\bf Imaginary Part');
  end
  
  if(doplots(3)) % absolute value
    fig(3) = figure('Name','Plane wave DG finite elements');
    patch('faces', Elements, ...
          'vertices', [Coordinates, abs(Values)], ...
          'CData', abs(Values), ...
          'facecolor', 'interp', ...
          'edgecolor', 'none');
    set(gca,'XLim',XLim,'YLim',YLim,'CLim',CLimAbs,'DataAspectRatio',[1 1 1]);
    title('\bf Absolute Value');
  end

  if(nargout > 0)
    varargout = num2cell(fig(doplots));
  end
  
return